"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var attributes_1 = __importDefault(require("./attributes"));
var nylas_connection_1 = __importDefault(require("../nylas-connection"));
var RestfulModel = /** @class */ (function () {
    function RestfulModel(connection, json) {
        this.connection = connection;
        if (!(this.connection instanceof nylas_connection_1.default)) {
            throw new Error('Connection object not provided');
        }
        if (json) {
            this.fromJSON(json);
        }
    }
    RestfulModel.prototype.attributes = function () {
        return this.constructor.attributes;
    };
    RestfulModel.prototype.isEqual = function (other) {
        return ((other ? other.id : undefined) === this.id &&
            (other ? other.constructor : undefined) === this.constructor);
    };
    RestfulModel.prototype.fromJSON = function (json) {
        if (json === void 0) { json = {}; }
        var attributes = this.attributes();
        for (var attrName in attributes) {
            var attr = attributes[attrName];
            if (json[attr.jsonKey] !== undefined) {
                this[attrName] = attr.fromJSON(json[attr.jsonKey], this);
            }
        }
        return this;
    };
    RestfulModel.prototype.toJSON = function (enforceReadOnly) {
        var json = {};
        var attributes = this.attributes();
        for (var attrName in attributes) {
            var attr = attributes[attrName];
            if (enforceReadOnly === true) {
                json[attr.jsonKey] = attr.saveRequestBody(this[attrName]);
            }
            else {
                json[attr.jsonKey] = attr.toJSON(this[attrName]);
            }
        }
        return json;
    };
    // Subclasses should override this method.
    RestfulModel.prototype.pathPrefix = function () {
        return '';
    };
    RestfulModel.prototype.saveEndpoint = function () {
        var collectionName = this.constructor.collectionName;
        return this.pathPrefix() + "/" + collectionName;
    };
    // saveRequestBody is used by save(). It returns a JSON dict containing only the
    // fields the API allows updating. Subclasses should override this method.
    RestfulModel.prototype.saveRequestBody = function () {
        return this.toJSON(true);
    };
    // deleteRequestQueryString is used by delete(). Subclasses should override this method.
    RestfulModel.prototype.deleteRequestQueryString = function (_params) {
        return {};
    };
    // deleteRequestBody is used by delete(). Subclasses should override this method.
    RestfulModel.prototype.deleteRequestBody = function (_params) {
        return {};
    };
    // deleteRequestOptions is used by delete(). Subclasses should override this method.
    RestfulModel.prototype.deleteRequestOptions = function (params) {
        return {
            body: this.deleteRequestBody(params),
            qs: this.deleteRequestQueryString(params),
        };
    };
    RestfulModel.prototype.toString = function () {
        return JSON.stringify(this.toJSON());
    };
    // Not every model needs to have a save function, but those who
    // do shouldn't have to reimplement the same boilerplate.
    // They should instead define a save() function which calls _save.
    RestfulModel.prototype._save = function (params, callback) {
        var _this = this;
        if (params === void 0) { params = {}; }
        if (typeof params === 'function') {
            callback = params;
            params = {};
        }
        return this.connection
            .request({
            method: this.id ? 'PUT' : 'POST',
            body: this.saveRequestBody(),
            qs: params,
            path: this.id
                ? this.saveEndpoint() + "/" + this.id
                : "" + this.saveEndpoint(),
            baseUrl: this.baseUrl,
        })
            .then(function (json) {
            _this.fromJSON(json);
            if (callback) {
                callback(null, _this);
            }
            return Promise.resolve(_this);
        })
            .catch(function (err) {
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        });
    };
    RestfulModel.prototype._get = function (params, callback, pathSuffix) {
        if (params === void 0) { params = {}; }
        if (pathSuffix === void 0) { pathSuffix = ''; }
        var collectionName = this.constructor.collectionName;
        return this.connection
            .request({
            method: 'GET',
            path: "/" + collectionName + "/" + this.id + pathSuffix,
            qs: params,
            baseUrl: this.baseUrl,
        })
            .then(function (response) {
            if (callback) {
                callback(null, response);
            }
            return Promise.resolve(response);
        })
            .catch(function (err) {
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        });
    };
    RestfulModel.endpointName = ''; // overrridden in subclasses
    RestfulModel.collectionName = ''; // overrridden in subclasses
    return RestfulModel;
}());
exports.default = RestfulModel;
RestfulModel.attributes = {
    id: attributes_1.default.String({
        modelKey: 'id',
        readOnly: true,
    }),
    object: attributes_1.default.String({
        modelKey: 'object',
        readOnly: true,
    }),
    accountId: attributes_1.default.String({
        modelKey: 'accountId',
        jsonKey: 'account_id',
        readOnly: true,
    }),
};
