"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var message_1 = __importDefault(require("./message"));
var nylas_connection_1 = __importDefault(require("../nylas-connection"));
var thread_1 = __importDefault(require("./thread"));
var REQUEST_CHUNK_SIZE = 100;
var RestfulModelCollection = /** @class */ (function () {
    function RestfulModelCollection(modelClass, connection) {
        this.modelClass = modelClass;
        this.connection = connection;
        if (!(this.connection instanceof nylas_connection_1.default)) {
            throw new Error('Connection object not provided');
        }
        if (!this.modelClass) {
            throw new Error('Model class not provided');
        }
    }
    RestfulModelCollection.prototype.forEach = function (params, eachCallback, completeCallback) {
        var _this = this;
        if (params === void 0) { params = {}; }
        if (params.view == 'count') {
            var err = new Error('forEach() cannot be called with the count view');
            if (completeCallback) {
                completeCallback(err);
            }
            return Promise.reject(err);
        }
        var offset = 0;
        var iteratee = function () {
            return _this._getItems(params, offset, REQUEST_CHUNK_SIZE).then(function (items) {
                for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                    var item = items_1[_i];
                    eachCallback(item);
                }
                offset += items.length;
                var finished = items.length < REQUEST_CHUNK_SIZE;
                if (finished === false) {
                    return iteratee();
                }
            });
        };
        iteratee().then(function () {
            if (completeCallback) {
                completeCallback();
            }
        }, function (err) {
            if (completeCallback) {
                return completeCallback(err);
            }
        });
    };
    RestfulModelCollection.prototype.count = function (params, callback) {
        if (params === void 0) { params = {}; }
        return this.connection
            .request({
            method: 'GET',
            path: this.path(),
            qs: __assign({ view: 'count' }, params),
            baseUrl: this.baseUrl,
        })
            .then(function (json) {
            if (callback) {
                callback(null, json.count);
            }
            return Promise.resolve(json.count);
        })
            .catch(function (err) {
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        });
    };
    RestfulModelCollection.prototype.first = function (params, callback) {
        if (params === void 0) { params = {}; }
        if (params.view == 'count') {
            var err = new Error('first() cannot be called with the count view');
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        }
        return this._getItems(params, 0, 1)
            .then(function (items) {
            if (callback) {
                callback(null, items[0]);
            }
            return Promise.resolve(items[0]);
        })
            .catch(function (err) {
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        });
    };
    RestfulModelCollection.prototype.list = function (params, callback) {
        if (params === void 0) { params = {}; }
        if (params.view == 'count') {
            var err = new Error('list() cannot be called with the count view');
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        }
        var limit = params.limit || Infinity;
        var offset = params.offset;
        return this._range({ params: params, offset: offset, limit: limit, callback: callback });
    };
    RestfulModelCollection.prototype.find = function (id, paramsArg, callbackArg) {
        // callback used to be the second argument, and params was the third
        var callback;
        if (typeof callbackArg === 'function') {
            callback = callbackArg;
        }
        else if (typeof paramsArg === 'function') {
            callback = paramsArg;
        }
        var params = {};
        if (paramsArg && typeof paramsArg === 'object') {
            params = paramsArg;
        }
        else if (callbackArg && typeof callbackArg === 'object') {
            params = callbackArg;
        }
        if (!id) {
            var err = new Error('find() must be called with an item id');
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        }
        if (params.view == 'count' || params.view == 'ids') {
            var err = new Error('find() cannot be called with the count or ids view');
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        }
        return this._getModel(id, params)
            .then(function (model) {
            if (callback) {
                callback(null, model);
            }
            return Promise.resolve(model);
        })
            .catch(function (err) {
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        });
    };
    RestfulModelCollection.prototype.search = function (query, params, callback) {
        if (params === void 0) { params = {}; }
        if (this.modelClass != message_1.default && this.modelClass != thread_1.default) {
            var err = new Error('search() can only be called for messages and threads');
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        }
        if (!query) {
            var err = new Error('search() requires a query string');
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        }
        params.q = query;
        var limit = params.limit || 40;
        var offset = params.offset;
        var path = this.path() + "/search";
        return this._range({ params: params, offset: offset, limit: limit, path: path });
    };
    RestfulModelCollection.prototype.delete = function (itemOrId, params, callback) {
        if (params === void 0) { params = {}; }
        if (!itemOrId) {
            var err = new Error('delete() requires an item or an id');
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        }
        if (typeof params === 'function') {
            callback = params;
            params = {};
        }
        var item = typeof itemOrId === 'string' ? this.build({ id: itemOrId }) : itemOrId;
        var options = item.deleteRequestOptions(params);
        options.item = item;
        return this.deleteItem(options, callback);
    };
    RestfulModelCollection.prototype.deleteItem = function (options, callbackArg) {
        var item = options.item;
        // callback used to be in the options object
        var callback = options.callback ? options.callback : callbackArg;
        var body = options.hasOwnProperty('body')
            ? options.body
            : item.deleteRequestBody({});
        var qs = options.hasOwnProperty('qs')
            ? options.qs
            : item.deleteRequestQueryString({});
        return this.connection
            .request({
            method: 'DELETE',
            qs: qs,
            body: body,
            path: this.path() + "/" + item.id,
            baseUrl: this.baseUrl,
        })
            .then(function (data) {
            if (callback) {
                callback(null, data);
            }
            return Promise.resolve(data);
        })
            .catch(function (err) {
            if (callback) {
                callback(err);
            }
            return Promise.reject(err);
        });
    };
    RestfulModelCollection.prototype.build = function (args) {
        var model = this._createModel({});
        for (var key in args) {
            var val = args[key];
            model[key] = val;
        }
        return model;
    };
    RestfulModelCollection.prototype.path = function () {
        return "/" + this.modelClass.collectionName;
    };
    RestfulModelCollection.prototype._range = function (_a) {
        var _this = this;
        var _b = _a.params, params = _b === void 0 ? {} : _b, _c = _a.offset, offset = _c === void 0 ? 0 : _c, _d = _a.limit, limit = _d === void 0 ? 100 : _d, callback = _a.callback, path = _a.path;
        var accumulated = [];
        var iteratee = function () {
            var chunkOffset = offset + accumulated.length;
            var chunkLimit = Math.min(REQUEST_CHUNK_SIZE, limit - accumulated.length);
            return _this._getItems(params, chunkOffset, chunkLimit, path).then(function (items) {
                accumulated = accumulated.concat(items);
                var finished = items.length < REQUEST_CHUNK_SIZE || accumulated.length >= limit;
                if (finished === false) {
                    return iteratee();
                }
            });
        };
        // do not return rejected promise when callback is provided
        // to prevent unhandled rejection warning
        return iteratee().then(function () {
            if (callback) {
                return callback(null, accumulated);
            }
            return accumulated;
        }, function (err) {
            if (callback) {
                return callback(err);
            }
            throw err;
        });
    };
    RestfulModelCollection.prototype._getItems = function (params, offset, limit, path) {
        // Items can be either models or ids
        if (!path) {
            path = this.path();
        }
        if (params.view == 'ids') {
            return this.connection.request({
                method: 'GET',
                path: path,
                qs: __assign(__assign({}, params), { offset: offset, limit: limit }),
                baseUrl: this.baseUrl,
            });
        }
        return this._getModelCollection(params, offset, limit, path);
    };
    RestfulModelCollection.prototype._createModel = function (json) {
        return new this.modelClass(this.connection, json);
    };
    RestfulModelCollection.prototype._getModel = function (id, params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        return this.connection
            .request({
            method: 'GET',
            path: this.path() + "/" + id,
            qs: params,
            baseUrl: this.baseUrl,
        })
            .then(function (json) {
            var model = _this._createModel(json);
            return Promise.resolve(model);
        });
    };
    RestfulModelCollection.prototype._getModelCollection = function (params, offset, limit, path) {
        var _this = this;
        return this.connection
            .request({
            method: 'GET',
            path: path,
            qs: __assign(__assign({}, params), { offset: offset, limit: limit }),
            baseUrl: this.baseUrl,
        })
            .then(function (jsonArray) {
            var models = jsonArray.map(function (json) {
                return _this._createModel(json);
            });
            return Promise.resolve(models);
        });
    };
    return RestfulModelCollection;
}());
exports.default = RestfulModelCollection;
